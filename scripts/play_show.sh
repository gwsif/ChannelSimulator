#!/bin/bash
# ::::::::::::::::::::::::::::::::::::::::::::.
# C H A N N E L  S I M U L A T O R
# `````````````````````````````````````````````
# TELEVISION BROADCAST SIMULATOR
# Â©KEVAN PLEDGER 2023
# ::::::::::::::::::::::::::::::::::::::::::::.
#
# PLAY SHOW SCRIPT
#    PLAYS A SINGLE SHOW SEGMENT. IF A CSBREAK FILE IS FOUND, THEN IT WILL PLAY THE VIDEO UNTIL THE FIRST ENCOUNTERED
#    TIMESTAMP IN THE CSBREAK FILE, AND THEN PLAY COMMERCIALS. IF THERE IS NO NEXT ENTRY IN THE CSBREAK FILE, THE ENDING DURATION
#    IS CALCULATED TO BE THE TOTAL LENGTH OF THE VIDEO SUBTRACTED BY THE LAST TIMESTAMPS VALUE PLUS OUR OFFSET. IF NO CSBREAK FILE
#    IS FOUND THEN IT WILL PLAY THE ENTIRE EPISODE FOLLOWED BY EXACTLY ONE SET OF COMMERCIALS. A BLOCK IS CONSIDERED AS FINISHED 
#    WHEN THE FINAL PORTION OF THE EPISODE PLAYS. SHOW BROADCASTS WILL ALWAYS START WITH ONE AD-BLOCK PRIOR TO BROADCAST!
#--------------------------------------------------------------------------------------
# ALWAYS SOURCE OUR CONFIG
source config/channel_simulator.cfg

# ANNOUNCE START OF SHOW BLOCK TO CONSOLE
echo "---SHOW BLOCK STARTING---"

# REASSIGN DIRECTORY VARIABLE FOR LEGIBILITY
CS_SHOW_DIR="$1"

# CHANGE INTO THE SHOW DIRECTORY
cd "$CS_SHOW_DIR"

# ASSIGN THE FILEPATHS OF EACH FILE IN THE DIRECTORY TO AN ARRAY
CS_SHOW_MASTERLIST=()
for show in *
    do
        CS_SHOW_MASTERLIST=("${CS_SHOW_MASTERLIST[@]}" "$show")
    done
    
# GENERATE A RANDOM NUMBER SEED BETWEEN CS_SHOW_MIN AND CS_SHOW_MAX
# ASSUME WE WILL ALWAYS HAVE THIS MANY SHOWS
CS_SHOW_MIN=1
    
# GET NUMBER OF FILES IN DIRECTORY AND ADD ONE TO ACCOUNT FOR ARRAY!
CS_SHOW_MAX=$(expr $(find . -maxdepth 1 -type f | wc -l) - 1)

# GENERATE A RANDOM NUMBER BETWEEN OUR MINIMUM AND MAXIMUM NUMBERS
CS_SHOW_RAND_SEED=$(shuf -i "$CS_SHOW_MIN-$CS_SHOW_MAX" -n 1)

# GET OUR RANDOM EPISODE
CS_SHOW_SELECTED="${CS_SHOW_MASTERLIST[$CS_SHOW_RAND_SEED]}"

# GET THE RUNTIME OF OUR RANDOM EPISODE
CS_SHOW_RUNTIME=$(mediainfo --Inform="General;%Duration%" "$CS_SHOW_SELECTED")

# RUNTIME IS IN MILLISECONDS, CHANGE TO SECONDS FOR TIMEOUT
CS_SHOW_RUNTIME=$(expr $CS_SHOW_RUNTIME / 1000)
    
# ANNOUNCE SELECTED FILE TO CONSOLE
echo "SELECTED FILE: $CS_SHOW_SELECTED"
echo "RUNTIME: $CS_SHOW_RUNTIME"
echo "BEGINNING PLAYBACK VIA: $CS_MEDIAPLAYER"
    
# PLAY VIDEO
if [[ "$CS_MEDIAPLAYER" = 'vlc' ]];
    then
        # IF OUR MEDIAPLAYER IS VLC WE ARE FIRST CLASS!
        timeout $CS_SHOW_RUNTIME "$CS_MEDIAPLAYER" -I dummy --fullscreen --qt-minimal-view --no-qt-name-in-title --no-video-deco --no-embedded-video "$CS_SHOW_SELECTED"
        #timeout 10s "$CS_MEDIAPLAYER" -I dummy --fullscreen --qt-minimal-view --no-qt-name-in-title --no-video-deco --no-embedded-video "$CS_SHOW_SELECTED"
    
    else
        # OTHERWISE ASSUME STANDARD MEDIA PLAYER
	    #timeout 10s "$CS_MEDIAPLAYER" "$CS_COMM_SELECTED"
        timeout $CS_SHOW_RUNTIME "$CS_MEDIAPLAYER" "$CS_SHOW_SELECTED"
fi

# PURGE SELECTED AND MASTERLIST!
CS_SHOW_SELECTED=""
CS_SHOW_MASTERLIST=()

# ANNOUNCE END OF SHOW
echo "---SHOW BLOCK ENDING---"

# AND RETURN
return